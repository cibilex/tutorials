Not:grup katÄ±ldÄ±ÄŸÄ±nda grupta zaten eklenmiÅŸ mi kontrol et.



ctx.message>{from:{kimden},chat:{type:grup mu Ã¶zel gÃ¶rÃ¼ÅŸme mi}}
ctx.botInfo>{bot bilgilerini veri.  }
ctx.reply("") mesaj gÃ¶nderme
ctx.replyWithHTML( "<i>username </i>", ) Sadece bunlar desteklenir:
<b>bold</b>, <strong>bold</strong>
<i>italic</i>, <em>italic</em>
<u>underline</u>, <ins>underline</ins>
<s>strikethrough</s>, <strike>strikethrough</strike>, <del>strikethrough</del>
<b>bold <i>italic bold <s>italic bold strikethrough</s> <u>underline italic bold</u></i> bold</b>
<a href="http://www.example.com/">inline URL</a>
<a href="tg://user?id=123456789">inline mention of a user</a>
<code>inline fixed-width code</code>
<pre>pre-formatted fixed-width code block</pre>
<pre><code class="language-python">pre-formatted fixed-width code block written in the Python programming language</code></pre>

-Herhangi bir dosya gÃ¶nderirken resim,video,metin..: metin kÄ±smÄ±nda markdown kullanmak iÃ§in options kÄ±smÄ±nda parse_mode:"Markdown"
*bold \*text*
_italic \*text_
__underline__
~strikethrough~
*bold _italic bold ~italic bold strikethrough~ __underline italic bold___ bold*
[inline URL](http://www.example.com/)
[inline mention of a user](tg://user?id=123456789)
`inline fixed-width code`
```
pre-formatted fixed-width code block
```
```python
pre-formatted fixed-width code block written in the Python programming language
```  //bÃ¶ylece bu stiller kullanÄ±labilir. 
bot.on('sticker', (ctx) => ctx.reply('ğŸ‘'))   //private kÄ±smÄ±nda Ã§alÅŸÄ±yor ancak gruplarda Ã§alÄ±ÅŸmÄ±yor.
bot.on('sticker')>ctx.message kÄ±smÄ±nda sticker objesi gelir.


-bir metin gÃ¶nderirken options kÄ±smÄ±nda aktif keyboardÄ± silmesini saÄŸlayabiliriz.
  ctx.reply("button deleted",{reply_markup: {remove_keyboard: true}})
dosya gÃ¶nderimi:
    video:    ctx.replyWithVideo({source:path})       //dosya yolu veya
      ctx.replyWithVideo({
    source: fs.createReadStream('/path/to/video.mp4')
  })

    resim:    ctx.replyWithPhoto('https://picsum.photos/200/300/')  //url ile veya     Ã¼
     ctx.replyWithPhoto({
        url: 'https://picsum.photos/200/300/?random',
        filename: 'kitten.jpg'
      })

    sticker:  ctx.replyWithSticker('123123jkbhj6b')        //file_id ile gÃ¶nderilir.

    ses:  ctx.replyWithVoice({
    source: Buffer.alloc()
  })

  middleware: await next() sonraki midleeware geÃ§er ve onun bitmesini bekler
  bot.use(async (ctx, next) => {
  console.time(`Processing update ${ctx.update.update_id}`)
  await next() // runs next middleware
  // runs after next middleware finishes
  console.timeEnd(`Processing update ${ctx.update.update_id}`)
})

Mesaj silme:ctx.deleteMessage(mesaj_id) mesaj id yazÄ±lmazsa son mesajÄ± siler.
    const is=await ctx.deleteMessage(357)
    console.log(is)

    private mod:botfather ile deÄŸiÅŸtirilebilir:DeÄŸiÅŸikliÄŸi tanÄ±mlamak iÃ§in botu kaldÄ±rÄ±p tekrar yÃ¼klemek gerek.
    enabled:sadece komut ve bota Ã¶zel mesajlarÄ± algÄ±lar.
    disabled : tÃ¼m mesajlarÄ± algÄ±lar.

    botu sohbetten atmak:
    bot.command('quit', (ctx) => {
  ctx.telegram.leaveChat(ctx.message.chat.id)
  ctx.leaveChat()
      })

      Ãœye iÅŸlemleri:belirtilen parametreler zorunlu deÄŸil.Parametre konulmazsa mesajÄ± yazandan yola Ã§Ä±kÄ±lÄ±r.  
      ctx.getChat(chat_id) chat dÃ¶ndÃ¼rÃ¼lÃ¼r.ctx.message.chat ile ortak yanlarÄ± var.
      ctx.getChatAdministrators(chat_id)
      ctx.getChatMember(userId veya chat_id)
      ctx.getChatMemberCount(chat_id)

     ctx vs telegram: ctx kullanÄ±rken belirtilen Ã§oÄŸu alanÄ±n doldurulmasÄ± zorunlu deÄŸilken telegramde zorunludur.(TÃ¼m alanlar deÄŸil.)
     Telegram tanÄ±mlama:
     const { Telegraf ,Telegram}=require("telegraf")
     const telegram=new Telegram(token)
     ctx:her isteÄŸin callbacÄŸindeki ctx.


     Bot tanÄ±mlama:oluÅŸturma: 
     -keyboard ve inline keyboard:
     keyboard:footer kÄ±smÄ±nda gÃ¶sterir.DeÄŸer mesaj olarak yazÄ±lÄ±r.
       Markup.removeKeyboard() ile silinmesi gerekir ancak silinmiyor onun yerine.
         ctx.reply("button deleted",{reply_markup: {remove_keyboard: true}} ile siliniebilir.
     inlineKeyboard:mesajÄ±n altÄ±nda gÃ¶sterilir.DeÄŸer callback ile dÃ¶ner.Mesaj olarak yazÄ±lmaz.
     const { Markup}=require("telegraf")
      Markup.keyboard([])
    Ã¶rnek1:
  ctx.reply("bot gelioo",Markup.keyboard([
    ["mehmet","ahmet"], //1.satÄ±r
    ["deli","veli"]//2.satÄ±r
  ]).oneTime().placeholder())   //placeholder inputta gÃ¶rÃ¼necek kÄ±sm.oneTime sadece tek kullanÄ±mlÄ±k der. resize() ve selective() de kullanÄ±lÄ±r.
                                //butona tÄ±kladÄ±ÄŸÄ±nda buton deÄŸeri text eÅŸit olur.ve mesaj olarak gelir.

  Ã¶rnek2: ctx.reply(
    'Special buttons keyboard',
    Markup.keyboard([
      Markup.button.contactRequest('Send contact'),     //tel no ister
      Markup.button.locationRequest('Send location')      //lokasyon ister
    ]).resize()
  )   //ctx.message.contact ile tel no alÄ±nÄ±r. 
      //ctx.message.location ile locasyon alÄ±nÄ±r.

      bot.on("location") ve bot.on("contact") ile bilgiler alÄ±nabilir.

      Ã¶rnek3:
          Markup.keyboard(['one', 'two', 'three', 'four', 'five', 'six'], {
      wrap: (btn, index, currentRow) => currentRow.length >= (index + 1 ) / 2
    })   //indexleme dÃ¶ndÃ¼rÃ¼len deÄŸere gÃ¶re yapÄ±lÄ±r.
    
    Ã¶rnek4:bot.action('Dr Pepper', (ctx, next) => {
  return ctx.reply('ğŸ‘').then(() => next())
})  //botun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ deÄŸer Dr Pepper ise Ã§alÄ±ÅŸtÄ±rÄ±r ardÄ±ndan devam ettirir.

Inline keyboard:metin kÄ±smÄ±nda metnin altÄ±na konur.
    Markup.inlineKeyboard([
      Markup.button.callback('Coke', 'Coke'),
      Markup.button.callback('Dr Pepper', 'Dr Pepper', Math.random() > 0.1),
    ])

      Markup.button.callback(label, val, true gizler.false gÃ¶sterir),
-Inline keyboardta gelen bilgile
bot.action("data") ile yakalanÄ±r.
-ctx.answerCbQuery("text",options) ile cevap verilebilir.true dÃ¶ner iÅŸlem tamamlanÄ±rsa.text kÄ±smÄ±nÄ± doldurmak zorunlu deÄŸildir.options={ show_alert:true}
    Ã¶rnek1:ctx.reply(
    'random example',
    Markup.inlineKeyboard([
      Markup.button.callback('Coke', 'Coke'),
      Markup.button.callback('Dr Pepper', 'Dr Pepper', Math.random() > 0.1),
      Markup.button.callback('Pepsi', 'Pepsi',true)
    ])
    Ã¶rnek2:  return ctx.replyWithPhoto({ url: 'https://picsum.photos/200/300/?random' },
    {
      caption: 'Caption',
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard([
        Markup.button.callback('Plain', 'plain'),
        Markup.button.callback('Italic', 'italic')
      ])
    }
  ) //options kÄ±smÄ±nda eklendiÄŸinde ... ile eklenir.

  bot.action('italic', async (ctx) => {
  await ctx.answerCbQuery()
  await ctx.editMessageCaption('_Caption_', {
    parse_mode: 'Markdown',
    ...Markup.inlineKeyboard([
      Markup.button.callback('Plain', 'plain'),
      Markup.button.callback('* Italic *', 'italic')
    ])
  })
}) //resimle kullanÄ±mÄ±


Telegraf api:
const bot=new Telegraf(token)
bot.hears("asd") asd mesajÄ± yazÄ±ldÄ±ÄŸÄ±nda 
bot.command("log") /log komutu yazÄ±lÄ±nca
bot.on("photo,audio,contact,location,groupchat_created..") gibi pek Ã§ok tetikleme ile Ã§alÄ±ÅŸan middleware saÄŸlar.
bot.action("") callback query iÃ§in Ã§alÄ±ÅŸacak middleware.Markup.button.callback('Plain', 'plain'), iÃ§in.



Hata ayÄ±klama:Default olarak telegram tekrar dener ve ardÄ±ndan consola yazar.App Ã§Ã¶ker.
Bunu engellemek iÃ§in: bot.catch(err=>)
err.response=hata bilgilerini
err.on=hatanÄ±n olduÄŸu bÃ¶lge

 Soru-cevap questionlarÄ± oluÅŸturma:npm install grammy @grammyjs/stateless-question ile yapÄ±lÄ±r.Ã–zel soru-cevap iliÅŸkisi saÄŸlar.

 Ã‡oklu soru cevap iÃ§im.Form ÅŸeklinde tek tek aÅŸamalÄ± ÅŸekilde sahneler iÃ§in.Scenes kullanÄ±lÄ±r.session gereklidir.
 link:https://github.com/telegraf/telegraf/issues/705 
 const {Scenes,session}=require("telegraf")
 const contactDataWizard = new Scenes.WizardScene(
  'CONTACT_DATA_WIZARD_SCENE_ID', // first argument is Scene_ID, same as for BaseScene //Ã¶zel ad
  (ctx) => {
    ctx.reply('What is your name?');
    ctx.wizard.state.contactData = {};
    return ctx.wizard.next();
  },
  (ctx) => {
    // validation example
    if (ctx.message.text.length < 2) {
      ctx.reply('Please enter name for real');
      return; 
    }
    ctx.wizard.state.contactData.fio = ctx.message.text;
    ctx.reply('Enter your e-mail');
    return ctx.wizard.back()
    return ctx.wizard.next();
  },
  async (ctx) => {
    ctx.wizard.state.contactData.email = ctx.message.text;
    ctx.reply("Thank you for your replies, we'll contact your soon");
    console.log(ctx.wizard.state.contactData)
    // await mySendContactDataMomentBeforeErase(ctx.wizard.state.contactData);
    return ctx.scene.leave();
  },
  );

  const stage = new Scenes.Stage([contactDataWizard]);
  bot.use(session()); 
  bot.use(stage.middleware());
   bot.hears('s',(ctx) => ctx.scene.enter('CONTACT_DATA_WIZARD_SCENE_ID')); 

-aÅŸamala kÄ±sÄ±mlarÄ±nda geÃ§iÅŸler yapmak:
  ctx.wizard.next() - to advance to next step;
ctx.wizard.back() - to go back to previous step;
ctx.wizard.cursor - to get current step index;
ctx.wizard.selectStep(index) - to jump straight to a given step index, can be used to implement branching;

-ctx.scene.enter("",step) olarak kullanÄ±labilir ve atÄ±fta yapÄ±lan index hemen baÅŸlanÄ±r.
